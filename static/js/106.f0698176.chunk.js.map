{"version":3,"file":"static/js/106.f0698176.chunk.js","mappings":"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","sources":["../node_modules/@headlessui/react/src/utils/render.ts","../node_modules/@headlessui/react/src/components/keyboard.ts","../node_modules/@headlessui/react/src/utils/match.ts","../node_modules/@headlessui/react/src/hooks/use-sync-refs.ts","../node_modules/@headlessui/react/src/utils/bugs.ts","../node_modules/@headlessui/react/src/hooks/use-iso-morphic-effect.ts","../node_modules/@headlessui/react/src/hooks/use-server-handoff-complete.ts","../node_modules/@headlessui/react/src/hooks/use-id.ts","../node_modules/@headlessui/react/src/utils/focus-management.ts","../node_modules/@headlessui/react/src/hooks/use-window-event.ts","../node_modules/@headlessui/react/src/internal/open-closed.tsx","../node_modules/@headlessui/react/src/components/popover/popover.tsx","../node_modules/@headlessui/react/src/hooks/use-resolve-button-type.ts"],"sourcesContent":["import {\n  Fragment,\n  cloneElement,\n  createElement,\n  forwardRef,\n  isValidElement,\n\n  // Types\n  ElementType,\n  ReactElement,\n} from 'react'\nimport { Props, XOR, __, Expand } from '../types'\nimport { match } from './match'\n\nexport enum Features {\n  /** No features at all */\n  None = 0,\n\n  /**\n   * When used, this will allow us to use one of the render strategies.\n   *\n   * **The render strategies are:**\n   *    - **Unmount**   _(Will unmount the component.)_\n   *    - **Hidden**    _(Will hide the component using the [hidden] attribute.)_\n   */\n  RenderStrategy = 1,\n\n  /**\n   * When used, this will allow the user of our component to be in control. This can be used when\n   * you want to transition based on some state.\n   */\n  Static = 2,\n}\n\nexport enum RenderStrategy {\n  Unmount,\n  Hidden,\n}\n\ntype PropsForFeature<TPassedInFeatures extends Features, TForFeature extends Features, TProps> = {\n  [P in TPassedInFeatures]: P extends TForFeature ? TProps : __\n}[TPassedInFeatures]\n\nexport type PropsForFeatures<T extends Features> = XOR<\n  PropsForFeature<T, Features.Static, { static?: boolean }>,\n  PropsForFeature<T, Features.RenderStrategy, { unmount?: boolean }>\n>\n\nexport function render<TFeature extends Features, TTag extends ElementType, TSlot>({\n  props,\n  slot,\n  defaultTag,\n  features,\n  visible = true,\n  name,\n}: {\n  props: Expand<Props<TTag, TSlot, any> & PropsForFeatures<TFeature>>\n  slot?: TSlot\n  defaultTag: ElementType\n  features?: TFeature\n  visible?: boolean\n  name: string\n}) {\n  // Visible always render\n  if (visible) return _render(props, slot, defaultTag, name)\n\n  let featureFlags = features ?? Features.None\n\n  if (featureFlags & Features.Static) {\n    let { static: isStatic = false, ...rest } = props as PropsForFeatures<Features.Static>\n\n    // When the `static` prop is passed as `true`, then the user is in control, thus we don't care about anything else\n    if (isStatic) return _render(rest, slot, defaultTag, name)\n  }\n\n  if (featureFlags & Features.RenderStrategy) {\n    let { unmount = true, ...rest } = props as PropsForFeatures<Features.RenderStrategy>\n    let strategy = unmount ? RenderStrategy.Unmount : RenderStrategy.Hidden\n\n    return match(strategy, {\n      [RenderStrategy.Unmount]() {\n        return null\n      },\n      [RenderStrategy.Hidden]() {\n        return _render(\n          { ...rest, ...{ hidden: true, style: { display: 'none' } } },\n          slot,\n          defaultTag,\n          name\n        )\n      },\n    })\n  }\n\n  // No features enabled, just render\n  return _render(props, slot, defaultTag, name)\n}\n\nfunction _render<TTag extends ElementType, TSlot>(\n  props: Props<TTag, TSlot> & { ref?: unknown },\n  slot: TSlot = {} as TSlot,\n  tag: ElementType,\n  name: string\n) {\n  let { as: Component = tag, children, refName = 'ref', ...passThroughProps } = omit(props, [\n    'unmount',\n    'static',\n  ])\n\n  // This allows us to use `<HeadlessUIComponent as={MyComponent} refName=\"innerRef\" />`\n  let refRelatedProps = props.ref !== undefined ? { [refName]: props.ref } : {}\n\n  let resolvedChildren = (typeof children === 'function' ? children(slot) : children) as\n    | ReactElement\n    | ReactElement[]\n\n  // Allow for className to be a function with the slot as the contents\n  if (passThroughProps.className && typeof passThroughProps.className === 'function') {\n    ;(passThroughProps as any).className = passThroughProps.className(slot)\n  }\n\n  if (Component === Fragment) {\n    if (Object.keys(passThroughProps).length > 0) {\n      if (\n        !isValidElement(resolvedChildren) ||\n        (Array.isArray(resolvedChildren) && resolvedChildren.length > 1)\n      ) {\n        throw new Error(\n          [\n            'Passing props on \"Fragment\"!',\n            '',\n            `The current component <${name} /> is rendering a \"Fragment\".`,\n            `However we need to passthrough the following props:`,\n            Object.keys(passThroughProps)\n              .map(line => `  - ${line}`)\n              .join('\\n'),\n            '',\n            'You can apply a few solutions:',\n            [\n              'Add an `as=\"...\"` prop, to ensure that we render an actual element instead of a \"Fragment\".',\n              'Render a single element as the child so that we can forward the props onto that element.',\n            ]\n              .map(line => `  - ${line}`)\n              .join('\\n'),\n          ].join('\\n')\n        )\n      }\n\n      return cloneElement(\n        resolvedChildren,\n        Object.assign(\n          {},\n          // Filter out undefined values so that they don't override the existing values\n          mergeEventFunctions(compact(omit(passThroughProps, ['ref'])), resolvedChildren.props, [\n            'onClick',\n          ]),\n          refRelatedProps\n        )\n      )\n    }\n  }\n\n  return createElement(\n    Component,\n    Object.assign({}, omit(passThroughProps, ['ref']), Component !== Fragment && refRelatedProps),\n    resolvedChildren\n  )\n}\n\n/**\n * We can use this function for the following useCase:\n *\n * <Menu.Item> <button onClick={console.log} /> </Menu.Item>\n *\n * Our `Menu.Item` will have an internal `onClick`, if you passthrough an `onClick` to the actual\n * `Menu.Item` component we will call it correctly. However, when we have an `onClick` on the actual\n * first child, that one should _also_ be called (but before this implementation, it was just\n * overriding the `onClick`). But it is only when we *render* that we have access to the existing\n * props of this component.\n *\n * It's a bit hacky, and not that clean, but it is something internal and we have tests to rely on\n * so that we can refactor this later (if needed).\n */\nfunction mergeEventFunctions(\n  passThroughProps: Record<string, any>,\n  existingProps: Record<string, any>,\n  functionsToMerge: string[]\n) {\n  let clone = Object.assign({}, passThroughProps)\n  for (let func of functionsToMerge) {\n    if (passThroughProps[func] !== undefined && existingProps[func] !== undefined) {\n      Object.assign(clone, {\n        [func](event: { defaultPrevented: boolean }) {\n          // Props we control\n          if (!event.defaultPrevented) passThroughProps[func](event)\n\n          // Existing props on the component\n          if (!event.defaultPrevented) existingProps[func](event)\n        },\n      })\n    }\n  }\n\n  return clone\n}\n\n/**\n * This is a hack, but basically we want to keep the full 'API' of the component, but we do want to\n * wrap it in a forwardRef so that we _can_ passthrough the ref\n */\nexport function forwardRefWithAs<T extends { name: string; displayName?: string }>(\n  component: T\n): T & { displayName: string } {\n  return Object.assign(forwardRef((component as unknown) as any) as any, {\n    displayName: component.displayName ?? component.name,\n  })\n}\n\nfunction compact<T extends Record<any, any>>(object: T) {\n  let clone = Object.assign({}, object)\n  for (let key in clone) {\n    if (clone[key] === undefined) delete clone[key]\n  }\n  return clone\n}\n\nfunction omit<T extends Record<any, any>>(object: T, keysToOmit: string[] = []) {\n  let clone = Object.assign({}, object)\n  for (let key of keysToOmit) {\n    if (key in clone) delete clone[key]\n  }\n  return clone\n}\n","// TODO: This must already exist somewhere, right? ðŸ¤”\n// Ref: https://www.w3.org/TR/uievents-key/#named-key-attribute-values\nexport enum Keys {\n  Space = ' ',\n  Enter = 'Enter',\n  Escape = 'Escape',\n  Backspace = 'Backspace',\n\n  ArrowLeft = 'ArrowLeft',\n  ArrowUp = 'ArrowUp',\n  ArrowRight = 'ArrowRight',\n  ArrowDown = 'ArrowDown',\n\n  Home = 'Home',\n  End = 'End',\n\n  PageUp = 'PageUp',\n  PageDown = 'PageDown',\n\n  Tab = 'Tab',\n}\n","export function match<TValue extends string | number = string, TReturnValue = unknown>(\n  value: TValue,\n  lookup: Record<TValue, TReturnValue | ((...args: any[]) => TReturnValue)>,\n  ...args: any[]\n): TReturnValue {\n  if (value in lookup) {\n    let returnValue = lookup[value]\n    return typeof returnValue === 'function' ? returnValue(...args) : returnValue\n  }\n\n  let error = new Error(\n    `Tried to handle \"${value}\" but there is no handler defined. Only defined handlers are: ${Object.keys(\n      lookup\n    )\n      .map(key => `\"${key}\"`)\n      .join(', ')}.`\n  )\n  if (Error.captureStackTrace) Error.captureStackTrace(error, match)\n  throw error\n}\n","import { useRef, useEffect, useCallback } from 'react'\n\nexport function useSyncRefs<TType>(\n  ...refs: (React.MutableRefObject<TType | null> | ((instance: TType) => void) | null)[]\n) {\n  let cache = useRef(refs)\n\n  useEffect(() => {\n    cache.current = refs\n  }, [refs])\n\n  return useCallback(\n    (value: TType) => {\n      for (let ref of cache.current) {\n        if (ref == null) continue\n        if (typeof ref === 'function') ref(value)\n        else ref.current = value\n      }\n    },\n    [cache]\n  )\n}\n","// See: https://github.com/facebook/react/issues/7711\n// See: https://github.com/facebook/react/pull/20612\n// See: https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#concept-fe-disabled (2.)\nexport function isDisabledReactIssue7711(element: Element): boolean {\n  let parent = element.parentElement\n  let legend = null\n\n  while (parent && !(parent instanceof HTMLFieldSetElement)) {\n    if (parent instanceof HTMLLegendElement) legend = parent\n    parent = parent.parentElement\n  }\n\n  let isParentDisabled = parent?.getAttribute('disabled') === '' ?? false\n  if (isParentDisabled && isFirstLegend(legend)) return false\n\n  return isParentDisabled\n}\n\nfunction isFirstLegend(element: HTMLLegendElement | null): boolean {\n  if (!element) return false\n\n  let previous = element.previousElementSibling\n\n  while (previous !== null) {\n    if (previous instanceof HTMLLegendElement) return false\n    previous = previous.previousElementSibling\n  }\n\n  return true\n}\n","import { useLayoutEffect, useEffect } from 'react'\n\nexport const useIsoMorphicEffect = typeof window !== 'undefined' ? useLayoutEffect : useEffect\n","import { useState, useEffect } from 'react'\n\nlet state = { serverHandoffComplete: false }\n\nexport function useServerHandoffComplete() {\n  let [serverHandoffComplete, setServerHandoffComplete] = useState(state.serverHandoffComplete)\n\n  useEffect(() => {\n    if (serverHandoffComplete === true) return\n\n    setServerHandoffComplete(true)\n  }, [serverHandoffComplete])\n\n  useEffect(() => {\n    if (state.serverHandoffComplete === false) state.serverHandoffComplete = true\n  }, [])\n\n  return serverHandoffComplete\n}\n","import { useState } from 'react'\nimport { useIsoMorphicEffect } from './use-iso-morphic-effect'\nimport { useServerHandoffComplete } from './use-server-handoff-complete'\n\n// We used a \"simple\" approach first which worked for SSR and rehydration on the client. However we\n// didn't take care of the Suspense case. To fix this we used the approach the @reach-ui/auto-id\n// uses.\n//\n// Credits: https://github.com/reach/reach-ui/blob/develop/packages/auto-id/src/index.tsx\n\nlet id = 0\nfunction generateId() {\n  return ++id\n}\n\nexport function useId() {\n  let ready = useServerHandoffComplete()\n  let [id, setId] = useState(ready ? generateId : null)\n\n  useIsoMorphicEffect(() => {\n    if (id === null) setId(generateId())\n  }, [id])\n\n  return id != null ? '' + id : undefined\n}\n","import { match } from './match'\n\n// Credit:\n//  - https://stackoverflow.com/a/30753870\nlet focusableSelector = [\n  '[contentEditable=true]',\n  '[tabindex]',\n  'a[href]',\n  'area[href]',\n  'button:not([disabled])',\n  'iframe',\n  'input:not([disabled])',\n  'select:not([disabled])',\n  'textarea:not([disabled])',\n]\n  .map(\n    process.env.NODE_ENV === 'test'\n      ? // TODO: Remove this once JSDOM fixes the issue where an element that is\n        // \"hidden\" can be the document.activeElement, because this is not possible\n        // in real browsers.\n        selector => `${selector}:not([tabindex='-1']):not([style*='display: none'])`\n      : selector => `${selector}:not([tabindex='-1'])`\n  )\n  .join(',')\n\nexport enum Focus {\n  /** Focus the first non-disabled element */\n  First = 1 << 0,\n\n  /** Focus the previous non-disabled element */\n  Previous = 1 << 1,\n\n  /** Focus the next non-disabled element */\n  Next = 1 << 2,\n\n  /** Focus the last non-disabled element */\n  Last = 1 << 3,\n\n  /** Wrap tab around */\n  WrapAround = 1 << 4,\n\n  /** Prevent scrolling the focusable elements into view */\n  NoScroll = 1 << 5,\n}\n\nexport enum FocusResult {\n  /** Something went wrong while trying to focus. */\n  Error,\n\n  /** When `Focus.WrapAround` is enabled, going from position `N` to `N+1` where `N` is the last index in the array, then we overflow. */\n  Overflow,\n\n  /** Focus was successful. */\n  Success,\n\n  /** When `Focus.WrapAround` is enabled, going from position `N` to `N-1` where `N` is the first index in the array, then we underflow. */\n  Underflow,\n}\n\nenum Direction {\n  Previous = -1,\n  Next = 1,\n}\n\nexport function getFocusableElements(container: HTMLElement | null = document.body) {\n  if (container == null) return []\n  return Array.from(container.querySelectorAll<HTMLElement>(focusableSelector))\n}\n\nexport enum FocusableMode {\n  /** The element itself must be focusable. */\n  Strict,\n\n  /** The element should be inside of a focusable element. */\n  Loose,\n}\n\nexport function isFocusableElement(\n  element: HTMLElement,\n  mode: FocusableMode = FocusableMode.Strict\n) {\n  if (element === document.body) return false\n\n  return match(mode, {\n    [FocusableMode.Strict]() {\n      return element.matches(focusableSelector)\n    },\n    [FocusableMode.Loose]() {\n      let next: HTMLElement | null = element\n\n      while (next !== null) {\n        if (next.matches(focusableSelector)) return true\n        next = next.parentElement\n      }\n\n      return false\n    },\n  })\n}\n\nexport function focusElement(element: HTMLElement | null) {\n  element?.focus({ preventScroll: true })\n}\n\nexport function focusIn(container: HTMLElement | HTMLElement[], focus: Focus) {\n  let elements = Array.isArray(container) ? container : getFocusableElements(container)\n  let active = document.activeElement as HTMLElement\n\n  let direction = (() => {\n    if (focus & (Focus.First | Focus.Next)) return Direction.Next\n    if (focus & (Focus.Previous | Focus.Last)) return Direction.Previous\n\n    throw new Error('Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last')\n  })()\n\n  let startIndex = (() => {\n    if (focus & Focus.First) return 0\n    if (focus & Focus.Previous) return Math.max(0, elements.indexOf(active)) - 1\n    if (focus & Focus.Next) return Math.max(0, elements.indexOf(active)) + 1\n    if (focus & Focus.Last) return elements.length - 1\n\n    throw new Error('Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last')\n  })()\n\n  let focusOptions = focus & Focus.NoScroll ? { preventScroll: true } : {}\n\n  let offset = 0\n  let total = elements.length\n  let next = undefined\n  do {\n    // Guard against infinite loops\n    if (offset >= total || offset + total <= 0) return FocusResult.Error\n\n    let nextIdx = startIndex + offset\n\n    if (focus & Focus.WrapAround) {\n      nextIdx = (nextIdx + total) % total\n    } else {\n      if (nextIdx < 0) return FocusResult.Underflow\n      if (nextIdx >= total) return FocusResult.Overflow\n    }\n\n    next = elements[nextIdx]\n\n    // Try the focus the next element, might not work if it is \"hidden\" to the user.\n    next?.focus(focusOptions)\n\n    // Try the next one in line\n    offset += direction\n  } while (next !== document.activeElement)\n\n  // This is a little weird, but let me try and explain: There are a few scenario's\n  // in chrome for example where a focused `<a>` tag does not get the default focus\n  // styles and sometimes they do. This highly depends on whether you started by\n  // clicking or by using your keyboard. When you programmatically add focus `anchor.focus()`\n  // then the active element (document.activeElement) is this anchor, which is expected.\n  // However in that case the default focus styles are not applied *unless* you\n  // also add this tabindex.\n  if (!next.hasAttribute('tabindex')) next.setAttribute('tabindex', '0')\n\n  return FocusResult.Success\n}\n","import { useEffect, useRef } from 'react'\n\nexport function useWindowEvent<TType extends keyof WindowEventMap>(\n  type: TType,\n  listener: (this: Window, ev: WindowEventMap[TType]) => any,\n  options?: boolean | AddEventListenerOptions\n) {\n  let listenerRef = useRef(listener)\n  listenerRef.current = listener\n\n  useEffect(() => {\n    function handler(event: WindowEventMap[TType]) {\n      listenerRef.current.call(window, event)\n    }\n\n    window.addEventListener(type, handler, options)\n    return () => window.removeEventListener(type, handler, options)\n  }, [type, options])\n}\n","import React, {\n  createContext,\n  useContext,\n\n  // Types\n  ReactNode,\n  ReactElement,\n} from 'react'\n\nlet Context = createContext<State | null>(null)\nContext.displayName = 'OpenClosedContext'\n\nexport enum State {\n  Open,\n  Closed,\n}\n\nexport function useOpenClosed() {\n  return useContext(Context)\n}\n\ninterface Props {\n  value: State\n  children: ReactNode\n}\n\nexport function OpenClosedProvider({ value, children }: Props): ReactElement {\n  return <Context.Provider value={value}>{children}</Context.Provider>\n}\n","import React, {\n  createContext,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useReducer,\n  useRef,\n  useState,\n\n  // Types\n  ContextType,\n  Dispatch,\n  ElementType,\n  KeyboardEvent as ReactKeyboardEvent,\n  MouseEvent as ReactMouseEvent,\n  Ref,\n  MutableRefObject,\n} from 'react'\n\nimport { Props } from '../../types'\nimport { match } from '../../utils/match'\nimport { forwardRefWithAs, render, Features, PropsForFeatures } from '../../utils/render'\nimport { useSyncRefs } from '../../hooks/use-sync-refs'\nimport { useId } from '../../hooks/use-id'\nimport { Keys } from '../keyboard'\nimport { isDisabledReactIssue7711 } from '../../utils/bugs'\nimport {\n  getFocusableElements,\n  Focus,\n  focusIn,\n  FocusResult,\n  isFocusableElement,\n  FocusableMode,\n} from '../../utils/focus-management'\nimport { useWindowEvent } from '../../hooks/use-window-event'\nimport { OpenClosedProvider, State, useOpenClosed } from '../../internal/open-closed'\nimport { useResolveButtonType } from '../../hooks/use-resolve-button-type'\n\nenum PopoverStates {\n  Open,\n  Closed,\n}\n\ninterface StateDefinition {\n  popoverState: PopoverStates\n\n  button: HTMLElement | null\n  buttonId: string\n  panel: HTMLElement | null\n  panelId: string\n}\n\nenum ActionTypes {\n  TogglePopover,\n  ClosePopover,\n\n  SetButton,\n  SetButtonId,\n  SetPanel,\n  SetPanelId,\n}\n\ntype Actions =\n  | { type: ActionTypes.TogglePopover }\n  | { type: ActionTypes.ClosePopover }\n  | { type: ActionTypes.SetButton; button: HTMLElement | null }\n  | { type: ActionTypes.SetButtonId; buttonId: string }\n  | { type: ActionTypes.SetPanel; panel: HTMLElement | null }\n  | { type: ActionTypes.SetPanelId; panelId: string }\n\nlet reducers: {\n  [P in ActionTypes]: (\n    state: StateDefinition,\n    action: Extract<Actions, { type: P }>\n  ) => StateDefinition\n} = {\n  [ActionTypes.TogglePopover]: state => ({\n    ...state,\n    popoverState: match(state.popoverState, {\n      [PopoverStates.Open]: PopoverStates.Closed,\n      [PopoverStates.Closed]: PopoverStates.Open,\n    }),\n  }),\n  [ActionTypes.ClosePopover](state) {\n    if (state.popoverState === PopoverStates.Closed) return state\n    return { ...state, popoverState: PopoverStates.Closed }\n  },\n  [ActionTypes.SetButton](state, action) {\n    if (state.button === action.button) return state\n    return { ...state, button: action.button }\n  },\n  [ActionTypes.SetButtonId](state, action) {\n    if (state.buttonId === action.buttonId) return state\n    return { ...state, buttonId: action.buttonId }\n  },\n  [ActionTypes.SetPanel](state, action) {\n    if (state.panel === action.panel) return state\n    return { ...state, panel: action.panel }\n  },\n  [ActionTypes.SetPanelId](state, action) {\n    if (state.panelId === action.panelId) return state\n    return { ...state, panelId: action.panelId }\n  },\n}\n\nlet PopoverContext = createContext<[StateDefinition, Dispatch<Actions>] | null>(null)\nPopoverContext.displayName = 'PopoverContext'\n\nfunction usePopoverContext(component: string) {\n  let context = useContext(PopoverContext)\n  if (context === null) {\n    let err = new Error(`<${component} /> is missing a parent <${Popover.name} /> component.`)\n    if (Error.captureStackTrace) Error.captureStackTrace(err, usePopoverContext)\n    throw err\n  }\n  return context\n}\n\nlet PopoverAPIContext = createContext<{\n  close(focusableElement?: HTMLElement | MutableRefObject<HTMLElement | null>): void\n} | null>(null)\nPopoverAPIContext.displayName = 'PopoverAPIContext'\n\nfunction usePopoverAPIContext(component: string) {\n  let context = useContext(PopoverAPIContext)\n  if (context === null) {\n    let err = new Error(`<${component} /> is missing a parent <${Popover.name} /> component.`)\n    if (Error.captureStackTrace) Error.captureStackTrace(err, usePopoverAPIContext)\n    throw err\n  }\n  return context\n}\n\nlet PopoverGroupContext = createContext<{\n  registerPopover(registerbag: PopoverRegisterBag): void\n  unregisterPopover(registerbag: PopoverRegisterBag): void\n  isFocusWithinPopoverGroup(): boolean\n  closeOthers(buttonId: string): void\n} | null>(null)\nPopoverGroupContext.displayName = 'PopoverGroupContext'\n\nfunction usePopoverGroupContext() {\n  return useContext(PopoverGroupContext)\n}\n\nlet PopoverPanelContext = createContext<string | null>(null)\nPopoverPanelContext.displayName = 'PopoverPanelContext'\n\nfunction usePopoverPanelContext() {\n  return useContext(PopoverPanelContext)\n}\n\ninterface PopoverRegisterBag {\n  buttonId: string\n  panelId: string\n  close(): void\n}\nfunction stateReducer(state: StateDefinition, action: Actions) {\n  return match(action.type, reducers, state, action)\n}\n\n// ---\n\nlet DEFAULT_POPOVER_TAG = 'div' as const\ninterface PopoverRenderPropArg {\n  open: boolean\n  close(focusableElement?: HTMLElement | MutableRefObject<HTMLElement | null>): void\n}\n\nexport function Popover<TTag extends ElementType = typeof DEFAULT_POPOVER_TAG>(\n  props: Props<TTag, PopoverRenderPropArg>\n) {\n  let buttonId = `headlessui-popover-button-${useId()}`\n  let panelId = `headlessui-popover-panel-${useId()}`\n\n  let reducerBag = useReducer(stateReducer, {\n    popoverState: PopoverStates.Closed,\n    button: null,\n    buttonId,\n    panel: null,\n    panelId,\n  } as StateDefinition)\n  let [{ popoverState, button, panel }, dispatch] = reducerBag\n\n  useEffect(() => dispatch({ type: ActionTypes.SetButtonId, buttonId }), [buttonId, dispatch])\n  useEffect(() => dispatch({ type: ActionTypes.SetPanelId, panelId }), [panelId, dispatch])\n\n  let registerBag = useMemo(\n    () => ({ buttonId, panelId, close: () => dispatch({ type: ActionTypes.ClosePopover }) }),\n    [buttonId, panelId, dispatch]\n  )\n\n  let groupContext = usePopoverGroupContext()\n  let registerPopover = groupContext?.registerPopover\n  let isFocusWithinPopoverGroup = useCallback(() => {\n    return (\n      groupContext?.isFocusWithinPopoverGroup() ??\n      (button?.contains(document.activeElement) || panel?.contains(document.activeElement))\n    )\n  }, [groupContext, button, panel])\n\n  useEffect(() => registerPopover?.(registerBag), [registerPopover, registerBag])\n\n  // Handle focus out\n  useWindowEvent(\n    'focus',\n    () => {\n      if (popoverState !== PopoverStates.Open) return\n      if (isFocusWithinPopoverGroup()) return\n      if (!button) return\n      if (!panel) return\n\n      dispatch({ type: ActionTypes.ClosePopover })\n    },\n    true\n  )\n\n  // Handle outside click\n  useWindowEvent('mousedown', event => {\n    let target = event.target as HTMLElement\n\n    if (popoverState !== PopoverStates.Open) return\n\n    if (button?.contains(target)) return\n    if (panel?.contains(target)) return\n\n    dispatch({ type: ActionTypes.ClosePopover })\n\n    if (!isFocusableElement(target, FocusableMode.Loose)) {\n      event.preventDefault()\n      button?.focus()\n    }\n  })\n\n  let close = useCallback(\n    (focusableElement?: HTMLElement | MutableRefObject<HTMLElement | null>) => {\n      dispatch({ type: ActionTypes.ClosePopover })\n\n      let restoreElement = (() => {\n        if (!focusableElement) return button\n        if (focusableElement instanceof HTMLElement) return focusableElement\n        if (focusableElement.current instanceof HTMLElement) return focusableElement.current\n\n        return button\n      })()\n\n      restoreElement?.focus()\n    },\n    [dispatch, button]\n  )\n\n  let api = useMemo<ContextType<typeof PopoverAPIContext>>(() => ({ close }), [close])\n\n  let slot = useMemo<PopoverRenderPropArg>(\n    () => ({ open: popoverState === PopoverStates.Open, close }),\n    [popoverState, close]\n  )\n\n  return (\n    <PopoverContext.Provider value={reducerBag}>\n      <PopoverAPIContext.Provider value={api}>\n        <OpenClosedProvider\n          value={match(popoverState, {\n            [PopoverStates.Open]: State.Open,\n            [PopoverStates.Closed]: State.Closed,\n          })}\n        >\n          {render({\n            props,\n            slot,\n            defaultTag: DEFAULT_POPOVER_TAG,\n            name: 'Popover',\n          })}\n        </OpenClosedProvider>\n      </PopoverAPIContext.Provider>\n    </PopoverContext.Provider>\n  )\n}\n\n// ---\n\nlet DEFAULT_BUTTON_TAG = 'button' as const\ninterface ButtonRenderPropArg {\n  open: boolean\n}\ntype ButtonPropsWeControl =\n  | 'id'\n  | 'type'\n  | 'aria-expanded'\n  | 'aria-controls'\n  | 'onKeyDown'\n  | 'onClick'\n\nlet Button = forwardRefWithAs(function Button<TTag extends ElementType = typeof DEFAULT_BUTTON_TAG>(\n  props: Props<TTag, ButtonRenderPropArg, ButtonPropsWeControl>,\n  ref: Ref<HTMLButtonElement>\n) {\n  let [state, dispatch] = usePopoverContext([Popover.name, Button.name].join('.'))\n  let internalButtonRef = useRef<HTMLButtonElement | null>(null)\n\n  let groupContext = usePopoverGroupContext()\n  let closeOthers = groupContext?.closeOthers\n\n  let panelContext = usePopoverPanelContext()\n  let isWithinPanel = panelContext === null ? false : panelContext === state.panelId\n\n  let buttonRef = useSyncRefs(\n    internalButtonRef,\n    ref,\n    isWithinPanel ? null : button => dispatch({ type: ActionTypes.SetButton, button })\n  )\n  let withinPanelButtonRef = useSyncRefs(internalButtonRef, ref)\n\n  // TODO: Revisit when handling Tab/Shift+Tab when using Portal's\n  let activeElementRef = useRef<Element | null>(null)\n  let previousActiveElementRef = useRef<Element | null>(\n    typeof window === 'undefined' ? null : document.activeElement\n  )\n  useWindowEvent(\n    'focus',\n    () => {\n      previousActiveElementRef.current = activeElementRef.current\n      activeElementRef.current = document.activeElement\n    },\n    true\n  )\n\n  let handleKeyDown = useCallback(\n    (event: ReactKeyboardEvent<HTMLButtonElement>) => {\n      if (isWithinPanel) {\n        if (state.popoverState === PopoverStates.Closed) return\n        switch (event.key) {\n          case Keys.Space:\n          case Keys.Enter:\n            event.preventDefault() // Prevent triggering a *click* event\n            event.stopPropagation()\n            dispatch({ type: ActionTypes.ClosePopover })\n            state.button?.focus() // Re-focus the original opening Button\n            break\n        }\n      } else {\n        switch (event.key) {\n          case Keys.Space:\n          case Keys.Enter:\n            event.preventDefault() // Prevent triggering a *click* event\n            event.stopPropagation()\n            if (state.popoverState === PopoverStates.Closed) closeOthers?.(state.buttonId)\n            dispatch({ type: ActionTypes.TogglePopover })\n            break\n\n          case Keys.Escape:\n            if (state.popoverState !== PopoverStates.Open) return closeOthers?.(state.buttonId)\n            if (!internalButtonRef.current) return\n            if (!internalButtonRef.current.contains(document.activeElement)) return\n            event.preventDefault()\n            event.stopPropagation()\n            dispatch({ type: ActionTypes.ClosePopover })\n            break\n\n          case Keys.Tab:\n            if (state.popoverState !== PopoverStates.Open) return\n            if (!state.panel) return\n            if (!state.button) return\n\n            // TODO: Revisit when handling Tab/Shift+Tab when using Portal's\n            if (event.shiftKey) {\n              // Check if the last focused element exists, and check that it is not inside button or panel itself\n              if (!previousActiveElementRef.current) return\n              if (state.button?.contains(previousActiveElementRef.current)) return\n              if (state.panel.contains(previousActiveElementRef.current)) return\n\n              // Check if the last focused element is *after* the button in the DOM\n              let focusableElements = getFocusableElements()\n              let previousIdx = focusableElements.indexOf(\n                previousActiveElementRef.current as HTMLElement\n              )\n              let buttonIdx = focusableElements.indexOf(state.button)\n              if (buttonIdx > previousIdx) return\n\n              event.preventDefault()\n              event.stopPropagation()\n\n              focusIn(state.panel, Focus.Last)\n            } else {\n              event.preventDefault()\n              event.stopPropagation()\n\n              focusIn(state.panel, Focus.First)\n            }\n\n            break\n        }\n      }\n    },\n    [\n      dispatch,\n      state.popoverState,\n      state.buttonId,\n      state.button,\n      state.panel,\n      internalButtonRef,\n      closeOthers,\n      isWithinPanel,\n    ]\n  )\n\n  let handleKeyUp = useCallback(\n    (event: ReactKeyboardEvent<HTMLButtonElement>) => {\n      if (isWithinPanel) return\n      if (event.key === Keys.Space) {\n        // Required for firefox, event.preventDefault() in handleKeyDown for\n        // the Space key doesn't cancel the handleKeyUp, which in turn\n        // triggers a *click*.\n        event.preventDefault()\n      }\n      if (state.popoverState !== PopoverStates.Open) return\n      if (!state.panel) return\n      if (!state.button) return\n\n      // TODO: Revisit when handling Tab/Shift+Tab when using Portal's\n      switch (event.key) {\n        case Keys.Tab:\n          // Check if the last focused element exists, and check that it is not inside button or panel itself\n          if (!previousActiveElementRef.current) return\n          if (state.button?.contains(previousActiveElementRef.current)) return\n          if (state.panel.contains(previousActiveElementRef.current)) return\n\n          // Check if the last focused element is *after* the button in the DOM\n          let focusableElements = getFocusableElements()\n          let previousIdx = focusableElements.indexOf(\n            previousActiveElementRef.current as HTMLElement\n          )\n          let buttonIdx = focusableElements.indexOf(state.button)\n          if (buttonIdx > previousIdx) return\n\n          event.preventDefault()\n          event.stopPropagation()\n          focusIn(state.panel, Focus.Last)\n          break\n      }\n    },\n    [state.popoverState, state.panel, state.button, isWithinPanel]\n  )\n\n  let handleClick = useCallback(\n    (event: ReactMouseEvent) => {\n      if (isDisabledReactIssue7711(event.currentTarget)) return\n      if (props.disabled) return\n      if (isWithinPanel) {\n        dispatch({ type: ActionTypes.ClosePopover })\n        state.button?.focus() // Re-focus the original opening Button\n      } else {\n        if (state.popoverState === PopoverStates.Closed) closeOthers?.(state.buttonId)\n        state.button?.focus()\n        dispatch({ type: ActionTypes.TogglePopover })\n      }\n    },\n    [\n      dispatch,\n      state.button,\n      state.popoverState,\n      state.buttonId,\n      props.disabled,\n      closeOthers,\n      isWithinPanel,\n    ]\n  )\n\n  let slot = useMemo<ButtonRenderPropArg>(\n    () => ({ open: state.popoverState === PopoverStates.Open }),\n    [state]\n  )\n\n  let type = useResolveButtonType(props, internalButtonRef)\n  let passthroughProps = props\n  let propsWeControl = isWithinPanel\n    ? {\n        ref: withinPanelButtonRef,\n        type,\n        onKeyDown: handleKeyDown,\n        onClick: handleClick,\n      }\n    : {\n        ref: buttonRef,\n        id: state.buttonId,\n        type,\n        'aria-expanded': props.disabled ? undefined : state.popoverState === PopoverStates.Open,\n        'aria-controls': state.panel ? state.panelId : undefined,\n        onKeyDown: handleKeyDown,\n        onKeyUp: handleKeyUp,\n        onClick: handleClick,\n      }\n\n  return render({\n    props: { ...passthroughProps, ...propsWeControl },\n    slot,\n    defaultTag: DEFAULT_BUTTON_TAG,\n    name: 'Popover.Button',\n  })\n})\n\n// ---\n\nlet DEFAULT_OVERLAY_TAG = 'div' as const\ninterface OverlayRenderPropArg {\n  open: boolean\n}\ntype OverlayPropsWeControl = 'id' | 'aria-hidden' | 'onClick'\n\nlet OverlayRenderFeatures = Features.RenderStrategy | Features.Static\n\nlet Overlay = forwardRefWithAs(function Overlay<\n  TTag extends ElementType = typeof DEFAULT_OVERLAY_TAG\n>(\n  props: Props<TTag, OverlayRenderPropArg, OverlayPropsWeControl> &\n    PropsForFeatures<typeof OverlayRenderFeatures>,\n  ref: Ref<HTMLDivElement>\n) {\n  let [{ popoverState }, dispatch] = usePopoverContext([Popover.name, Overlay.name].join('.'))\n  let overlayRef = useSyncRefs(ref)\n\n  let id = `headlessui-popover-overlay-${useId()}`\n\n  let usesOpenClosedState = useOpenClosed()\n  let visible = (() => {\n    if (usesOpenClosedState !== null) {\n      return usesOpenClosedState === State.Open\n    }\n\n    return popoverState === PopoverStates.Open\n  })()\n\n  let handleClick = useCallback(\n    (event: ReactMouseEvent) => {\n      if (isDisabledReactIssue7711(event.currentTarget)) return event.preventDefault()\n      dispatch({ type: ActionTypes.ClosePopover })\n    },\n    [dispatch]\n  )\n\n  let slot = useMemo<OverlayRenderPropArg>(() => ({ open: popoverState === PopoverStates.Open }), [\n    popoverState,\n  ])\n  let propsWeControl = {\n    ref: overlayRef,\n    id,\n    'aria-hidden': true,\n    onClick: handleClick,\n  }\n  let passthroughProps = props\n\n  return render({\n    props: { ...passthroughProps, ...propsWeControl },\n    slot,\n    defaultTag: DEFAULT_OVERLAY_TAG,\n    features: OverlayRenderFeatures,\n    visible,\n    name: 'Popover.Overlay',\n  })\n})\n\n// ---\n\nlet DEFAULT_PANEL_TAG = 'div' as const\ninterface PanelRenderPropArg {\n  open: boolean\n  close: (focusableElement?: HTMLElement | MutableRefObject<HTMLElement | null>) => void\n}\ntype PanelPropsWeControl = 'id' | 'onKeyDown'\n\nlet PanelRenderFeatures = Features.RenderStrategy | Features.Static\n\nlet Panel = forwardRefWithAs(function Panel<TTag extends ElementType = typeof DEFAULT_PANEL_TAG>(\n  props: Props<TTag, PanelRenderPropArg, PanelPropsWeControl> &\n    PropsForFeatures<typeof PanelRenderFeatures> & {\n      focus?: boolean\n    },\n  ref: Ref<HTMLDivElement>\n) {\n  let { focus = false, ...passthroughProps } = props\n\n  let [state, dispatch] = usePopoverContext([Popover.name, Panel.name].join('.'))\n  let { close } = usePopoverAPIContext([Popover.name, Panel.name].join('.'))\n\n  let internalPanelRef = useRef<HTMLDivElement | null>(null)\n  let panelRef = useSyncRefs(internalPanelRef, ref, panel => {\n    dispatch({ type: ActionTypes.SetPanel, panel })\n  })\n\n  let usesOpenClosedState = useOpenClosed()\n  let visible = (() => {\n    if (usesOpenClosedState !== null) {\n      return usesOpenClosedState === State.Open\n    }\n\n    return state.popoverState === PopoverStates.Open\n  })()\n\n  let handleKeyDown = useCallback(\n    (event: KeyboardEvent) => {\n      switch (event.key) {\n        case Keys.Escape:\n          if (state.popoverState !== PopoverStates.Open) return\n          if (!internalPanelRef.current) return\n          if (!internalPanelRef.current.contains(document.activeElement)) return\n          event.preventDefault()\n          event.stopPropagation()\n          dispatch({ type: ActionTypes.ClosePopover })\n          state.button?.focus()\n          break\n      }\n    },\n    [state, internalPanelRef, dispatch]\n  )\n\n  // Unlink on \"unmount\" myself\n  useEffect(() => () => dispatch({ type: ActionTypes.SetPanel, panel: null }), [dispatch])\n\n  // Unlink on \"unmount\" children\n  useEffect(() => {\n    if (props.static) return\n\n    if (state.popoverState === PopoverStates.Closed && (props.unmount ?? true)) {\n      dispatch({ type: ActionTypes.SetPanel, panel: null })\n    }\n  }, [state.popoverState, props.unmount, props.static, dispatch])\n\n  // Move focus within panel\n  useEffect(() => {\n    if (!focus) return\n    if (state.popoverState !== PopoverStates.Open) return\n    if (!internalPanelRef.current) return\n\n    let activeElement = document.activeElement as HTMLElement\n    if (internalPanelRef.current.contains(activeElement)) return // Already focused within Dialog\n\n    focusIn(internalPanelRef.current, Focus.First)\n  }, [focus, internalPanelRef, state.popoverState])\n\n  // Handle Tab / Shift+Tab focus positioning\n  useWindowEvent('keydown', event => {\n    if (state.popoverState !== PopoverStates.Open) return\n    if (!internalPanelRef.current) return\n    if (event.key !== Keys.Tab) return\n    if (!document.activeElement) return\n    if (!internalPanelRef.current) return\n    if (!internalPanelRef.current.contains(document.activeElement)) return\n\n    // We will take-over the default tab behaviour so that we have a bit\n    // control over what is focused next. It will behave exactly the same,\n    // but it will also \"fix\" some issues based on whether you are using a\n    // Portal or not.\n    event.preventDefault()\n\n    let result = focusIn(internalPanelRef.current, event.shiftKey ? Focus.Previous : Focus.Next)\n\n    if (result === FocusResult.Underflow) {\n      return state.button?.focus()\n    } else if (result === FocusResult.Overflow) {\n      if (!state.button) return\n\n      let elements = getFocusableElements()\n      let buttonIdx = elements.indexOf(state.button)\n\n      let nextElements = elements\n        .splice(buttonIdx + 1) // Elements after button\n        .filter(element => !internalPanelRef.current?.contains(element)) // Ignore items in panel\n\n      // Try to focus the next element, however it could fail if we are in a\n      // Portal that happens to be the very last one in the DOM. In that\n      // case we would Error (because nothing after the button is\n      // focusable). Therefore we will try and focus the very first item in\n      // the document.body.\n      if (focusIn(nextElements, Focus.First) === FocusResult.Error) {\n        focusIn(document.body, Focus.First)\n      }\n    }\n  })\n\n  // Handle focus out when we are in special \"focus\" mode\n  useWindowEvent(\n    'focus',\n    () => {\n      if (!focus) return\n      if (state.popoverState !== PopoverStates.Open) return\n      if (!internalPanelRef.current) return\n\n      if (internalPanelRef.current?.contains(document.activeElement as HTMLElement)) return\n      dispatch({ type: ActionTypes.ClosePopover })\n    },\n    true\n  )\n\n  let slot = useMemo<PanelRenderPropArg>(\n    () => ({ open: state.popoverState === PopoverStates.Open, close }),\n    [state, close]\n  )\n  let propsWeControl = {\n    ref: panelRef,\n    id: state.panelId,\n    onKeyDown: handleKeyDown,\n  }\n\n  return (\n    <PopoverPanelContext.Provider value={state.panelId}>\n      {render({\n        props: { ...passthroughProps, ...propsWeControl },\n        slot,\n        defaultTag: DEFAULT_PANEL_TAG,\n        features: PanelRenderFeatures,\n        visible,\n        name: 'Popover.Panel',\n      })}\n    </PopoverPanelContext.Provider>\n  )\n})\n\n// ---\n\nlet DEFAULT_GROUP_TAG = 'div' as const\ninterface GroupRenderPropArg {}\ntype GroupPropsWeControl = 'id'\n\nfunction Group<TTag extends ElementType = typeof DEFAULT_PANEL_TAG>(\n  props: Props<TTag, GroupRenderPropArg, GroupPropsWeControl>\n) {\n  let groupRef = useRef<HTMLElement | null>(null)\n  let [popovers, setPopovers] = useState<PopoverRegisterBag[]>([])\n\n  let unregisterPopover = useCallback(\n    (registerbag: PopoverRegisterBag) => {\n      setPopovers(existing => {\n        let idx = existing.indexOf(registerbag)\n        if (idx !== -1) {\n          let clone = existing.slice()\n          clone.splice(idx, 1)\n          return clone\n        }\n        return existing\n      })\n    },\n    [setPopovers]\n  )\n\n  let registerPopover = useCallback(\n    (registerbag: PopoverRegisterBag) => {\n      setPopovers(existing => [...existing, registerbag])\n      return () => unregisterPopover(registerbag)\n    },\n    [setPopovers, unregisterPopover]\n  )\n\n  let isFocusWithinPopoverGroup = useCallback(() => {\n    let element = document.activeElement as HTMLElement\n\n    if (groupRef.current?.contains(element)) return true\n\n    // Check if the focus is in one of the button or panel elements. This is important in case you are rendering inside a Portal.\n    return popovers.some(bag => {\n      return (\n        document.getElementById(bag.buttonId)?.contains(element) ||\n        document.getElementById(bag.panelId)?.contains(element)\n      )\n    })\n  }, [groupRef, popovers])\n\n  let closeOthers = useCallback(\n    (buttonId: string) => {\n      for (let popover of popovers) {\n        if (popover.buttonId !== buttonId) popover.close()\n      }\n    },\n    [popovers]\n  )\n\n  let contextBag = useMemo<ContextType<typeof PopoverGroupContext>>(\n    () => ({\n      registerPopover: registerPopover,\n      unregisterPopover: unregisterPopover,\n      isFocusWithinPopoverGroup,\n      closeOthers,\n    }),\n    [registerPopover, unregisterPopover, isFocusWithinPopoverGroup, closeOthers]\n  )\n\n  let slot = useMemo<GroupRenderPropArg>(() => ({}), [])\n  let propsWeControl = { ref: groupRef }\n  let passthroughProps = props\n\n  return (\n    <PopoverGroupContext.Provider value={contextBag}>\n      {render({\n        props: { ...passthroughProps, ...propsWeControl },\n        slot,\n        defaultTag: DEFAULT_GROUP_TAG,\n        name: 'Popover.Group',\n      })}\n    </PopoverGroupContext.Provider>\n  )\n}\n\n// ---\n\nPopover.Button = Button\nPopover.Overlay = Overlay\nPopover.Panel = Panel\nPopover.Group = Group\n","import { useState, MutableRefObject } from 'react'\n\nimport { useIsoMorphicEffect } from './use-iso-morphic-effect'\n\nfunction resolveType<TTag>(props: { type?: string; as?: TTag }) {\n  if (props.type) return props.type\n\n  let tag = props.as ?? 'button'\n  if (typeof tag === 'string' && tag.toLowerCase() === 'button') return 'button'\n\n  return undefined\n}\n\nexport function useResolveButtonType<TTag>(\n  props: { type?: string; as?: TTag },\n  ref: MutableRefObject<HTMLElement | null>\n) {\n  let [type, setType] = useState(() => resolveType(props))\n\n  useIsoMorphicEffect(() => {\n    setType(resolveType(props))\n  }, [props.type, props.as])\n\n  useIsoMorphicEffect(() => {\n    if (type) return\n    if (!ref.current) return\n\n    if (ref.current instanceof HTMLButtonElement && !ref.current.hasAttribute('type')) {\n      setType('button')\n    }\n  }, [type, ref])\n\n  return type\n}\n"],"names":["Features","RenderStrategy","Keys","match","value","lookup","returnValue","args","error","Error","Object","key","render","props","slot","defaultTag","features","visible","name","_render","featureFlags","isStatic","rest","unmount","hidden","style","display","omit","as","Component","tag","children","refName","passThroughProps","refRelatedProps","resolvedChildren","isValidElement","Array","line","cloneElement","clone","func","existingProps","event","mergeEventFunctions","compact","createElement","forwardRefWithAs","component","forwardRef","displayName","keysToOmit","useSyncRefs","refs","cache","useRef","useEffect","useCallback","ref","isDisabledReactIssue7711","element","parent","legend","isParentDisabled","previous","isFirstLegend","useIsoMorphicEffect","window","state","serverHandoffComplete","id","generateId","useId","ready","useState","setServerHandoffComplete","useServerHandoffComplete","setId","Focus","FocusResult","FocusableMode","focusableSelector","selector","getFocusableElements","container","document","body","focusIn","focus","elements","active","direction","Direction","startIndex","Math","focusOptions","preventScroll","offset","total","next","nextIdx","useWindowEvent","type","listener","options","listenerRef","State","Context","createContext","useOpenClosed","useContext","OpenClosedProvider","resolveType","PopoverStates","ActionTypes","reducers","popoverState","Closed","action","button","buttonId","panel","panelId","PopoverContext","usePopoverContext","context","err","Popover","PopoverAPIContext","usePopoverAPIContext","PopoverGroupContext","usePopoverGroupContext","PopoverPanelContext","stateReducer","reducerBag","useReducer","dispatch","registerBag","useMemo","close","ClosePopover","groupContext","registerPopover","isFocusWithinPopoverGroup","target","mode","Strict","isFocusableElement","Loose","restoreElement","focusableElement","api","open","Open","Button","internalButtonRef","closeOthers","panelContext","isWithinPanel","buttonRef","withinPanelButtonRef","activeElementRef","previousActiveElementRef","handleKeyDown","Space","Enter","TogglePopover","Escape","Tab","focusableElements","previousIdx","Last","First","handleKeyUp","handleClick","setType","useResolveButtonType","onKeyDown","onClick","onKeyUp","OverlayRenderFeatures","Static","Overlay","overlayRef","usesOpenClosedState","PanelRenderFeatures","Panel","passthroughProps","internalPanelRef","panelRef","activeElement","result","Previous","Next","Underflow","Overflow","buttonIdx","propsWeControl","groupRef","popovers","setPopovers","unregisterPopover","existing","idx","bag","popover","contextBag"],"sourceRoot":""}